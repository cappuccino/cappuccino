#!/usr/bin/env node

// Note: This script is intended to be run with `objj` but its environment is Node.js.
// It relies on Objective-J being available in the runtime.

// Standard Node.js module imports ONLY
const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');


/**
 * A simple recursive file finder to replace the 'glob' package.
 * @param {string} startPath - The directory to start searching from.
 * @param {string} extension - The file extension to look for (e.g., '.cib').
 * @returns {string[]} An array of full file paths.
 */
function findFilesRecursiveSync(startPath, extension) {
    let results = [];
    try {
        const entries = fs.readdirSync(startPath, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(startPath, entry.name);
            if (entry.isDirectory()) {
                results = results.concat(findFilesRecursiveSync(fullPath, extension));
            } else if (entry.name.endsWith(extension)) {
                results.push(fullPath);
            }
        }
    } catch (err) {
        // Ignore errors from non-existent or unreadable directories
    }
    return results;
}

/**
 * Escapes special characters in a string for use in a regular expression.
 * @param {string} str The string to escape.
 * @returns {string} The escaped string.
 */
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * A simple, dependency-free argument parser to replace the 'yargs' package.
 */
function parseArguments(args) {
    const options = {
        main: 'main.j',
        frameworks: ['Frameworks'],
        force: false,
        index: 'index.html',
        pngcrush: false,
        verbose: false,
        _: [] // Positional arguments
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith('-')) {
            switch (arg) {
                case '-h':
                case '--help':
                    printUsage();
                    process.exit(0);
                case '-m':
                case '--main':
                    options.main = args[++i];
                    break;
                case '-F':
                case '--frameworks':
                    if (options.frameworks.length === 1 && options.frameworks[0] === 'Frameworks') {
                        options.frameworks = []; // Clear default if a new one is provided
                    }
                    options.frameworks.push(args[++i]);
                    break;
                case '-f':
                case '--force':
                    options.force = true;
                    break;
                case '--index':
                    options.index = args[++i];
                    break;
                case '-p':
                case '--pngcrush':
                    options.pngcrush = true;
                    break;
                case '--manifest':
                    options.manifest = true;
                    break;
                case '-v':
                case '--verbose':
                    options.verbose = true;
                    break;
                default:
                    console.error(`Unknown option: ${arg}`);
                    printUsage();
                    process.exit(1);
            }
        } else {
            options._.push(arg);
        }
    }
    return options;
}

function printUsage() {
    console.log(`
Usage: press INPUT_PROJECT OUTPUT_PROJECT [options]

Analyze and strip unused files from a Cappuccino project's .sj bundles.

Options:
  -m, --main <file>       The relative path to the main file (default: "main.j")
  -F, --frameworks <dir>  Add a frameworks directory (default: "Frameworks")
  -f, --force             Force overwriting OUTPUT_PROJECT if it exists
  --index <file>          The root HTML file to modify (default: "index.html")
  -p, --pngcrush          Run pngcrush on all PNGs (pngcrush must be installed)
  --manifest              Generate HTML5 cache manifest
  -v, --verbose           Verbose logging
  -h, --help              Show this help message
    `);
}

@import <Foundation/Foundation.j>
@import "../lib/cappuccino/objj-analysis-tools.j"
@import "../lib/cappuccino/cib-analysis-tools.j"
var CACHEMANIFEST = require("objective-j/cache-manifest");

function main() {
    // Slice off 'node' and script path
    const options = parseArguments(process.argv.slice(2));

    if (options._.length < 2) {
        console.error("Error: You must provide INPUT_PROJECT and OUTPUT_PROJECT paths.");
        printUsage();
        process.exit(1);
    }
    
    var [inputArg, outputArg] = options._;

    CPLogRegister(CPLogPrint);

    var rootPath = path.resolve(inputArg);
    var outputPath = path.resolve(outputArg);

    if (fs.existsSync(outputPath)) {
        if (options.force) {
            fs.rmSync(outputPath, { recursive: true, force: true });
        } else {
            console.log(`OUTPUT_PROJECT ${outputPath} exists. Use -f to overwrite.`);
            process.exit(1);
        }
    }

    press(rootPath, outputPath, options);
}

function press(rootPath, outputPath, options) {
    console.log("=".repeat(80));
    console.log("Application root:    " + rootPath);
    console.log("Output directory:    " + outputPath);

    var outputFiles = {},
        totalBytes = {executable:0, data:0, mhtml:0};

    var environment = "Browser";
    var returnedBytes = pressEnvironment(rootPath, outputFiles, environment, options);

    for (var i in returnedBytes)
        totalBytes[i] += returnedBytes[i];

    console.log(`PHASE 4: copy to output ${rootPath} => ${outputPath}`);

    fs.cpSync(rootPath, outputPath, { recursive: true });

    for (var filePath in outputFiles) {
        const relativePath = path.relative(rootPath, filePath);
        const fileInOutput = path.join(outputPath, relativePath);

        var parent = path.dirname(fileInOutput);
        if (!fs.existsSync(parent)) {
            CPLog.warn(parent + " doesn't exist, creating directories.");
            fs.mkdirSync(parent, { recursive: true });
        }

        if (typeof outputFiles[filePath] !== "string")
            outputFiles[filePath] = outputFiles[filePath].join("");

        const action = fs.existsSync(fileInOutput) ? "Overwriting:" : "Writing:";
        console.log(`${action}     ${fileInOutput}`);

        fs.writeFileSync(fileInOutput, outputFiles[filePath], { encoding : "UTF-8" });
    }

    console.log("PHASE 4a: Add application size data to Info.plist");

    var outputInfoPlistPath = path.join(outputPath, "Info.plist");
    var outputInfoPlistContents = fs.readFileSync(outputInfoPlistPath, { encoding:"UTF-8" });
    var format = CFPropertyList.sniffedFormatOfString(outputInfoPlistContents);
    var outputInfoPlist = CFPropertyList.propertyListFromString(outputInfoPlistContents);

    var themeName = outputInfoPlist.valueForKey("CPDefaultTheme") || "Aristo2";
    var themePath = null;

    if (themeName === "Aristo" || themeName === "Aristo2")
        themePath = path.join(outputPath, options.frameworks[0], "AppKit", "Resources", themeName + ".blend");
    else
        themePath = path.join(outputPath, "Resources", themeName + ".blend");

    if (fs.existsSync(themePath))
    {
        var themeEnvPath = path.join(themePath, environment + ".environment"),
            themeExecutablePath = path.join(themeEnvPath, themeName + ".blend.sj"),
            themeDataPath = path.join(themeEnvPath, "dataURLs.txt"),
            themeMHTMLPath = path.join(themeEnvPath, "MHTMLPaths.txt");

        totalBytes.executable += fs.readFileSync(themeExecutablePath, { encoding : "UTF-8" }).length;
        totalBytes.data += fs.readFileSync(themeDataPath, { encoding : "UTF-8" }).length;
        totalBytes.mhtml += fs.readFileSync(themeMHTMLPath, { encoding : "UTF-8" }).length;
    }

    outputInfoPlist.setValueForKey("CPApplicationSize", [CPDictionary.dictionaryWithJSObject(totalBytes)]);

    fs.writeFileSync(outputInfoPlistPath, CFPropertyList.stringFromPropertyList(outputInfoPlist, format), { encoding:"UTF-8" });

    if (options.pngcrush) {
        pngcrushDirectory(outputPath);
    }

    if (options.manifest) {
        CACHEMANIFEST.generateManifest(outputPath, {
            index : path.join(outputPath, options.index)
        });
    }
}

function pressEnvironment(rootPath, outputFiles, environment, options) {
    var mainPath = path.join(rootPath, options.main);
    var frameworks = options.frameworks.map(framework => path.join(rootPath, framework));

    console.log("=".repeat(80));
    console.log("Main file:           " + mainPath);
    console.log("Frameworks:          " + frameworks.join(', '));
    console.log("Environment:         " + environment);

    var analyzer = new ObjectiveJRuntimeAnalyzer(rootPath);
    var _OBJJ = analyzer.require("objective-j");

    analyzer.setIncludePaths(frameworks);
    analyzer.setEnvironments([environment, "ObjJ"]);

    var cibs = findFilesRecursiveSync(rootPath, ".cib").filter(p => !(/Frameworks/).test(p));

    console.log("PHASE 1: Loading application...");
    analyzer.initializeGlobalRecorder();
    analyzer.load(mainPath);
    analyzer.finishLoading();

    var dependencies = analyzer.mapGlobalsToFiles();

    console.log("Global defines:");
    Object.keys(dependencies).sort().forEach(function(identifier) {
        const relPaths = dependencies[identifier].map(p => path.relative(rootPath, p));
        console.log(identifier + " => " + relPaths.join(', '));
    });

    console.log("PHASE 2: Traverse dependency graph...");

    var requiredFiles = {};
    requiredFiles[mainPath] = true;

    var context = {
        ignoreFrameworkImports : true,
        ignoredImports: {},
        importCallback: (importing, imported) => { requiredFiles[imported] = true; },
        referenceCallback: (referencing, referenced) => { requiredFiles[referenced] = true; },
        progressCallback: (relPath) => { console.log("Processing "+relPath); },
        ignoreFrameworkImportsCallback : (relPath) => { console.log("Ignoring imports in "+relPath); }
    };

    var mainExecutable = analyzer.executableForImport(mainPath);

    analyzer.traverseDependencies(mainExecutable, context);

    var globalsToFiles = analyzer.mapGlobalsToFiles();
    cibs.forEach(function(cibPath) {
        var cibClasses = findCibClassDependencies(cibPath);
        console.log("Cib: " + path.relative(rootPath, cibPath) + " => " + cibClasses.join(', '));

        var referencedFiles = {};
        markFilesReferencedByTokens(cibClasses, globalsToFiles, referencedFiles);
        analyzer.checkReferenced(context, null, referencedFiles);
    });

    var included = 0, total = 0;
    var includedBytes = 0, totalBytes = 0, dataBytes = 0, mhtmlBytes = 0;

    _OBJJ.FileExecutable.allFileExecutables().forEach(function(aFileExecutable) {
        var filePath = aFileExecutable.path();
        if (/\.keyedtheme$/.test(filePath))
            requiredFiles[filePath] = true;

        if (requiredFiles[filePath]) {
            console.log("Included: " + path.relative(rootPath, filePath));
            included++;
            includedBytes += aFileExecutable.code().length;
        } else {
            console.log("Excluded: " + path.relative(rootPath, filePath));
        }
        total++;
        totalBytes += aFileExecutable.code().length;
    });

    console.log(_OBJJ.sprintf(
        `Saved %f%% (%s); Total required files: %d (%s) of %d (%s);`,
        Math.round(((includedBytes - totalBytes) / totalBytes) * -100),
        bytesToString(totalBytes - includedBytes),
        included, bytesToString(includedBytes),
        total, bytesToString(totalBytes)
    ));

    console.log("PHASE 3b: Rebuild .sj files");

    var processedBundles = {};

    for (var aPath in requiredFiles) {
        var executable = analyzer.executableForImport(aPath);
        var bundle = analyzer.context.global.CFBundle.bundleContainingURL(executable.path());
        var relativePath = path.relative(path.join(bundle.path(), ""), executable.path());

        if (executable.path() !== aPath)
            CPLog.warn("Sanity check failed (file path): " + executable.path() + " vs. " + aPath);

        if (bundle && bundle.infoDictionary()) {
            var executablePath = bundle.executablePath();
            if (executablePath) {
                if (context.ignoredImports[aPath]) {
                    console.log("Stripping extra imports from " + aPath);

                    var code = executable.code();
                    var dependencies = executable.fileDependencies();
                    var fileExecutableSearcher = executable.fileExecutableSearcher();
                    
                    for (var i = 0; i < dependencies.length; i++) {
                        var dependency = dependencies[i];
                        var dependencyExecutable = nil;

                        fileExecutableSearcher(dependency.URL(), dependency.isLocal(), function(aFileExecutable) {
                            dependencyExecutable = aFileExecutable;
                        });

                        var dependencyPath = dependencyExecutable.path();
                        if (!requiredFiles[dependencyPath]) {
                            console.log(" -> " + dependencyPath);
                            
                            var regex = new RegExp([
                                escapeRegExp("objj_executeFile"),
                                escapeRegExp("("),
                                "[\"']" + escapeRegExp(dependency.path()) + "[\"']",
                                escapeRegExp(","),
                                dependency.isLocal() ? "(true|YES)" : "(false|NO)",
                                escapeRegExp(")")
                            ].join("\\s*"), "g");
                            
                            var newCode = code.replace(regex, "/* $& */ (undefined)");
                            if (newCode === code) {
                                console.log(`Warning: Unable to strip import for ${dependency.path()} (${dependency.isLocal()})`);
                            }
                            code = newCode;
                            dependencies.splice(i--, 1);
                        }
                    }
                    if (code !== executable.code()) {
                        executable.setCode(code);
                    }
                }

                if (!outputFiles[executablePath]) {
                    outputFiles[executablePath] = [];
                    outputFiles[executablePath].push("@STATIC;1.0;");
                }

                var fileContents = executable.toMarkedString();
                outputFiles[executablePath].push("p;" + relativePath.length + ";" + relativePath);
                outputFiles[executablePath].push("t;" + fileContents.length + ";" + fileContents);

                console.log(`Adding ${path.relative(rootPath, aPath)} to ${path.relative(rootPath, executablePath)}`);
            } else {
                console.log("Passing .j through: " + path.relative(rootPath, aPath));
            }

            if (!processedBundles[bundle.path()] && bundle.hasSpritedImages()) {
                processedBundles[bundle.path()] = bundle;
                console.log("Sizing bundle's sprited resources " + bundle.path());

                var bundlePath = path.join(bundle.path(), environment + ".environment"),
                    bundleDataPath = path.join(bundlePath, "dataURLs.txt"),
                    bundleMHTMLPath = path.join(bundlePath, "MHTMLPaths.txt");

                dataBytes += fs.readFileSync(bundleDataPath, { encoding: "UTF-8" }).length;
                mhtmlBytes += fs.readFileSync(bundleMHTMLPath, { encoding: "UTF-8" }).length;
            }
        } else {
            CPLog.warn("No bundle (or info dictionary for) " + path.relative(rootPath, aPath));
        }
    }

    return { executable: includedBytes, data: dataBytes, mhtml: mhtmlBytes };
}

function pngcrushDirectory(directory) {
    const pngs = findFilesRecursiveSync(directory, ".png");
    
    process.stderr.write(`Running pngcrush on ${pngs.length} pngs:`);
    
    pngs.forEach(dstPath => {
        const tmpPath = dstPath + ".tmp";
        const result = spawnSync('pngcrush', ['-rem', 'alla', '-reduce', dstPath, tmpPath], { encoding: 'utf-8' });

        if (result.status !== 0) {
            CPLog.warn(`pngcrush failed for ${dstPath}. Ensure it's installed and on your PATH.`);
            if (result.stderr) CPLog.warn(result.stderr);
        } else {
            fs.renameSync(tmpPath, dstPath);
            process.stderr.write(".");
        }
    });
    
    process.stderr.write("\n");
}

function bytesToString(bytes) {
    var n = 0;
    while (bytes > 1024) {
        bytes /= 1024;
        n++;
    }
    return Math.round(bytes * 100) / 100 + " " + ["", "K", "M"][n] + "B";
}

// Execute the main function
main();
