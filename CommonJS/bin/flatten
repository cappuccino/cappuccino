#!/usr/bin/env node

/**
 * flatten (Modernized for Node.js and Aligned with Patch)
 *
 * This script combines a Cappuccino application into a single JavaScript file.
 * It is a fully modernized, dependency-free Node.js script that incorporates
 * the structural improvements from the provided patch, such as direct method
 * calls (e.g., this.objj_eval) and modern syntax.
 *
 * NOTE: The automatic compression feature has been removed. You should run a
 * JavaScript minifier (e.g., Terser) on the output file as a separate build step.
 */

// Standard Node.js module imports ONLY
const fs = require('fs');
const path = require('path');

// Aligned with patch: require the modernized analysis tools as a standard module.
const { ObjectiveJRuntimeAnalyzer } = require('./objj-analysis-tools.js');

// Cappuccino-specific Objective-J imports
@import <Foundation/Foundation.j>
var CACHEMANIFEST = require("objective-j/cache-manifest");

/**
 * A simple, dependency-free argument parser.
 */
function parseArguments(args) {
    const options = {
        main: 'main.j',
        frameworks: [],
        paths: [],
        force: false,
        index: 'index.html',
        split: 0,
        compressor: 'none',
        manifest: false,
        verbose: false,
        _: []
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith('-')) {
            switch (arg) {
                case '-h': case '--help': printUsage(); process.exit(0);
                case '-m': case '--main': options.main = args[++i]; break;
                case '-F': case '--framework': options.frameworks.push(args[++i]); break;
                case '-P': case '--path': options.paths.push(args[++i]); break;
                case '-f': case '--force': options.force = true; break;
                case '--index': options.index = args[++i]; break;
                case '-s': case '--split': options.split = parseInt(args[++i], 10); break;
                case '-c': case '--compressor':
                    options.compressor = args[++i];
                    if (options.compressor !== 'none') {
                        console.warn(`Warning: Compressor '${options.compressor}' is not supported. Compression is skipped.`);
                        options.compressor = 'none';
                    }
                    break;
                case '--manifest': options.manifest = true; break;
                case '-v': case '--verbose': options.verbose = true; break;
                default:
                    console.error(`Unknown option: ${arg}`);
                    printUsage();
                    process.exit(1);
            }
        } else {
            options._.push(arg);
        }
    }
    if (options.frameworks.length === 0) {
        options.frameworks.push('Frameworks');
    }
    return options;
}

function printUsage() {
    console.log(`
Usage: flatten INPUT_PROJECT OUTPUT_PROJECT [options]

Combine a Cappuccino application into a single JavaScript file.

Options:
  -m, --main <file>       The relative path to the main file (default: "main.j")
  -F, --framework <dir>   Add a frameworks directory (default: "Frameworks")
  -P, --path <path>       Add a path (relative to the app root) to inline
  -f, --force             Force overwriting OUTPUT_PROJECT if it exists
  --index <file>          The root HTML file to modify (default: "index.html")
  -c, --compressor <type> (none only) Compression is now a manual step.
  --manifest              Generate HTML5 cache manifest
  -v, --verbose           Verbose logging
  -h, --help              Show this help message
    `);
}

function main(args) {
    const options = parseArguments(args);
    if (options._.length < 2) {
        printUsage();
        return;
    }

    const rootPath = path.resolve(options._[0]);
    const outputPath = path.resolve(options._[1]);

    if (fs.existsSync(outputPath)) {
        if (options.force) {
            fs.rmSync(outputPath, { recursive: true, force: true });
        } else {
            console.error(`Error: OUTPUT_PROJECT ${outputPath} exists. Use -f to overwrite.`);
            process.exit(1);
        }
    }

    const mainPath = path.join(rootPath, options.main);
    const frameworks = options.frameworks.map(framework => path.join(rootPath, framework));
    const environment = "Browser";

    console.log("=".repeat(80));
    console.log("Application root:    " + rootPath);
    console.log("Output directory:    " + outputPath);
    console.log("Main file:           " + mainPath);

    const flattener = new ObjectiveJFlattener(rootPath);
    flattener.options = options;
    flattener.setIncludePaths(frameworks);
    flattener.setEnvironments([environment, "ObjJ"]);

    console.log("Loading application.");
    flattener.load(mainPath);

    console.log("Loading default theme.");
    // Aligned with patch: Use direct `objj_eval` and ES6 template literals.
    flattener.objj_eval(`(function() {
        var defaultThemeName = [CPApplication defaultThemeName],
            bundle = nil;
        if (defaultThemeName === @"Aristo" || defaultThemeName === @"Aristo2")
            bundle = [CPBundle bundleForClass:[CPApplication class]];
        else
            bundle = [CPBundle mainBundle];
        var blend = [[CPThemeBlend alloc] initWithContentsOfURL:[bundle pathForResource:defaultThemeName + @".blend"]];
        [blend loadWithDelegate:nil];
    })()`);

    const applicationJSs = flattener.buildApplicationJS();
    fs.cpSync(rootPath, outputPath, { recursive: true });

    applicationJSs.forEach((applicationJS, n) => {
        const name = "Application" + (n || "") + ".js";
        console.log(`Writing ${name}. (Compression is a manual step with a tool like 'terser')`);
        fs.writeFileSync(path.join(outputPath, name), applicationJS, 'utf8');
    });

    rewriteMainHTML(path.join(outputPath, options.index));

    if (options.manifest) {
        CACHEMANIFEST.generateManifest(outputPath, {
            index: path.join(outputPath, options.index),
            exclude: Object.keys(flattener.filesToCache).map(p => path.join(outputPath, p).toString())
        });
    }
}

function ObjectiveJFlattener(rootPath) {
    ObjectiveJRuntimeAnalyzer.call(this, rootPath);
    this.filesToCache = {};
    this.fileCacheBuffer = [];
    this.functionsBuffer = [];
}
ObjectiveJFlattener.prototype = Object.create(ObjectiveJRuntimeAnalyzer.prototype);

ObjectiveJFlattener.prototype.buildApplicationJS = function() {
    this.setupFileCache();
    this.serializeFunctions();
    this.serializeFileCache();

    // Aligned with patch: Use the corrected, shorter path.
    const additionsPath = path.resolve(__dirname, '..', 'lib', 'cappuccino', 'objj-flatten-additions.js');
    const additions = fs.readFileSync(additionsPath, 'utf8');

    const buffer = [];
    buffer.push("var baseURL = new CFURL(\".\", ObjectiveJ.pageURL);");
    buffer.push(additions);
    buffer.push(this.fileCacheBuffer.join("\n"));
    buffer.push(this.functionsBuffer.join("\n"));
    buffer.push("ObjectiveJ.bootstrap();");

    if (this.options.split > 0) {
        console.warn("Warning: The --split option is not supported in this version and will be ignored.");
    }
    
    return [buffer.join("\n")];
};

ObjectiveJFlattener.prototype.serializeFunctions = function() {
    const outputFiles = {};

    // Aligned with patch: Use the direct `this.FileExecutable` property.
    this.FileExecutable.allFileExecutables().forEach(executable => {
        const filePath = executable.path();
        const functionString = executable._function.toString().replace(", require, exports, module, system, print, window", "");
        const relative = path.relative(this.rootPath, filePath);
        this.functionsBuffer.push(`ObjectiveJ.FileExecutable._cacheFunction(new CFURL(${JSON.stringify(relative)}, baseURL),\n${functionString});`);

        // Aligned with patch: Use the direct `global.CFBundle` object.
        const bundle = global.CFBundle.bundleContainingURL(filePath);
        if (bundle && bundle.infoDictionary()) {
            const executablePath = bundle.executablePath();
            const relativeToBundle = path.relative(path.join(bundle.path(), ""), filePath);
            if (executablePath) {
                executable._code = `alert(${JSON.stringify(relativeToBundle)});`;
                if (!outputFiles[executablePath]) {
                    outputFiles[executablePath] = ["@STATIC;1.0;"];
                }
                const fileContents = executable.toMarkedString();
                outputFiles[executablePath].push(`p;${relativeToBundle.length};${relativeToBundle}`);
                outputFiles[executablePath].push(`t;${fileContents.length};${fileContents}`);
            }
        } else {
            console.warn(`Warning: No bundle (or info dictionary for) ${path.relative(this.rootPath, filePath)}`);
        }
    }, this);

    for (const executablePath in outputFiles) {
        const relative = path.relative(this.rootPath, executablePath);
        const contents = outputFiles[executablePath].join("");
        this.filesToCache[relative] = contents;
    }
};

ObjectiveJFlattener.prototype.serializeFileCache = function() {
    for (const relative in this.filesToCache) {
        const contents = this.filesToCache[relative];
        console.log(`Caching: ${relative} => ${contents == null ? 404 : 200}`);
        if (contents == null) {
            this.fileCacheBuffer.push(`CFHTTPRequest._cacheRequest(new CFURL(${JSON.stringify(relative)}, baseURL), 404);`);
        } else {
            this.fileCacheBuffer.push(`CFHTTPRequest._cacheRequest(new CFURL(${JSON.stringify(relative)}, baseURL), 200, {}, ${JSON.stringify(contents)});`);
        }
    }
};

ObjectiveJFlattener.prototype.setupFileCache = function() {
    const pathsToCache = {};
    Object.assign(pathsToCache, this.requestedURLs);

    this.options.paths.forEach(relativePath => {
        pathsToCache[path.join(this.rootPath, relativePath)] = true;
    }, this);

    Object.keys(pathsToCache).forEach(absolutePath => {
        const relative = path.relative(this.rootPath, absolutePath);
        if (relative.startsWith('..')) {
            console.log(`Skipping (parent of app root): ${absolutePath}`);
            return;
        }

        try {
            if (fs.statSync(absolutePath).isFile()) {
                const contents = fs.readFileSync(absolutePath, 'utf8');
                this.filesToCache[relative] = contents;
            } else {
                this.filesToCache[relative] = null;
            }
        } catch (e) {
            this.filesToCache[relative] = null;
        }
    }, this);
};

function rewriteMainHTML(indexHTMLPath) {
    const scriptTagsBefore = '$1<script type="text/javascript">OBJJ_AUTO_BOOTSTRAP = false;</script>';
    let scriptTagsAfter = '$1<script type="text/javascript" src="Application.js" charset="UTF-8"></script>';

    try {
        if (!fs.statSync(indexHTMLPath).isFile()) return;
        let indexHTML = fs.readFileSync(indexHTMLPath, 'utf8');
        const newIndexHTML = indexHTML.replace(
            /([ \t]+)<script[^>]+Objective-J\.js[^>]+>(?:\s*<\/script>)?/,
            `${scriptTagsBefore}\n$&\n${scriptTagsAfter}`
        );

        if (newIndexHTML !== indexHTML) {
            console.log(`Modified: ${indexHTMLPath}.`);
            fs.writeFileSync(indexHTMLPath, newIndexHTML, 'utf8');
        } else {
            console.warn(`Warning: Unable to automatically modify ${indexHTMLPath}. Please add script tags manually.`);
        }
    } catch (e) {
        console.warn(`Warning: ${indexHTMLPath} does not exist. Specify an alternate index HTML file with the --index option.`);
    }
}

// --- Run Main ---
main(process.argv.slice(2));
